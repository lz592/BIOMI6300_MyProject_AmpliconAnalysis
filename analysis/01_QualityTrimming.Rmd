---
title: "01_QualityTrimming"
by: Liangzi
output: html_document
date: "2025-03-01"
editor_options: 
  chunk_output_type: console
---
# HW_Sequence Quality Histogram
```{r}
install.packages("ggplot2")
install.packages("readr")

library(ggplot2)
library(readr)

setwd("/local/workdir/lz592/MyProject/data/fastqc_reports")

# Read FastQC quality data
fastqc_data <- readLines("/fastqc_reports/")

# Locate "Per base sequence quality" section 
start <- grep(">>Per base sequence quality", fastqc_data) + 1
end <- grep(">>END_MODULE", fastqc_data[start:length(fastqc_data)])[1] + start - 2
quality_data <- read.table(text = fastqc_data[start:end], header = TRUE)

ggplot(quality_data, aes(x = Base, y = Mean)) +
  geom_line(color = "blue") +
  geom_point(color = "red") +
  labs(title = "FastQC: Mean Quality Scores",
       x = "Position in read (bp)",
       y = "Phred Score") +
  theme_minimal()
```

# HW_Quality Trimming
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center",
                      fig.path = "/local/workdir/lz592/MyProject/figures/01_QualityTrimming/") # send any figure output to this folder 
```

```{r set-seed}
# Any number can be chosen 
set.seed(238428)
```

# Timing of Script
```{r rmd-start}
# What time did we start running this script? 
start_time <- Sys.time()
start_time
```

# Load Libraries 
```{r load-libraries}
# Efficient package loading with pacman 
# Don't forget to install pacman and DT if you don't have it yet.
pacman::p_load(tidyverse, BiocManager, devtools, dada2, 
               phyloseq, patchwork, DT, devtools, iNEXT, vegan, install = FALSE)
```

# Reading Raw Sequencing Files 
```{r load-data}
# Set the raw fastq path to the raw sequencing files 
# Path to the fastq files 
raw_fastqs_path <- "/local/workdir/lz592/MyProject/data/01_ena_data"
raw_fastqs_path

# What files are in this path? Intuition Check 
head(list.files(raw_fastqs_path))
# How many files are there? 
length(list.files(raw_fastqs_path))

# Create vector of forward reads
forward_reads <- list.files(raw_fastqs_path, pattern = "_1.fastq.gz", full.names = TRUE)  
# Intuition Checks 
head(forward_reads)
# Intuition check #2: We should have fewer reads in the forward vector than in total 
stopifnot(length(forward_reads) < length(list.files(raw_fastqs_path)))

# Create a vector of reverse reads 
reverse_reads <- list.files(raw_fastqs_path, pattern = "_2.fastq.gz", full.names = TRUE)
# Intuition Checks
head(reverse_reads)
# Intuition check #2: Need to have equal number of forward and reverse files 
stopifnot(length(reverse_reads) == length(forward_reads))
```

# Assess Raw Read Quality 
# Evaluate raw sequence quality
Seeing the quality of the raw reads *before* trimming
# Plot 12 random samples of plots 
```{r raw-quality-plot, fig.width=12, fig.height=8}
# Randomly select 12 samples from dataset to evaluate 
# Selecting 12 is typically better than 2 (like we did in class for efficiency)
random_samples <- sample(1:length(reverse_reads), size = 12)
random_samples
```
```{r raw-quality-plot, fig.width=12, fig.height=8}
# Calculate and plot quality of these two samples
forward_filteredQual_plot_12 <- plotQualityProfile(forward_reads[random_samples]) + 
  labs(title = "Forward Read: Raw Quality")

reverse_filteredQual_plot_12 <- plotQualityProfile(reverse_reads[random_samples]) + 
  labs(title = "Reverse Read: Raw Quality")

# Plot them together with patchwork
forward_filteredQual_plot_12 + reverse_filteredQual_plot_12
```

# Aggregated Raw Quality Plots
```{r}
# Aggregate all QC plots 
# Forward reads
forward_preQC_plot <- 
  plotQualityProfile(forward_reads, aggregate = TRUE) + 
  labs(title = "Forward Pre-QC")

# reverse reads
reverse_preQC_plot <- 
  plotQualityProfile(reverse_reads, aggregate = TRUE) + 
  labs(title = "Reverse Pre-QC")

# Now, let's put the two plots together
preQC_aggregate_plot <- 
  # Plot the forward and reverse together 
  forward_preQC_plot + reverse_preQC_plot
# Show the plot
preQC_aggregate_plot
```
## INTERPRETATION #1 of Pre-QC



# Prepare a placeholder for filtered reads
```{r}
# Create vector of sample names from the filenames 
sample_names <- sapply(strsplit(basename(forward_reads), "_"), `[`,1) 

# Intuition Check 
head(sample_names)
```

```{r}
# Place filtered reads into filtered_fastqs_path
filtered_fastqs_path <- "data/data/02_filtered_fastqs"

# Intuition Check 
filtered_fastqs_path
```

```{r}
# create 2 vectors: filtered_forward_reads & filtered_reverse_reads
filtered_forward_reads <- 
  file.path(filtered_fastqs_path, paste0(sample_names, "_1_filtered.fastq.gz"))

# Intuition Check 
length(filtered_forward_reads)
```

```{r}
# reverse reads
filtered_reverse_reads <- 
  file.path(filtered_fastqs_path, paste0(sample_names, "_2_filtered.fastq.gz"))

# Intuition Check 
head(filtered_reverse_reads)
```

# Filter and Trim Reads
```{r}
# Assign and write out filtered fastq files 
# Therefore, we do not need to trim the primers, because they were not sequenced
filtered_reads <- 
  filterAndTrim(fwd = forward_reads, filt = filtered_forward_reads,
              rev = reverse_reads, filt.rev = filtered_reverse_reads,
              maxN = 0, maxEE = c(2,2), 
              # Remove the first 8 bases at the beginning of the forward read
              trimLeft = 8,
              # Keep the full forward & trim final 2 bases in the reverse with truncLen
              truncLen = c(250, 248), 
              truncQ = 2, rm.phix = TRUE, compress = TRUE, multithread = TRUE)
```

# Assess Trimmed Read Quality
```{r}
# Plot the 12 random samples after QC
forward_filteredQual_plot_12 <- 
  plotQualityProfile(filtered_forward_reads[random_samples]) + 
  labs(title = "Trimmed Forward Read Quality")

reverse_filteredQual_plot_12 <- 
  plotQualityProfile(filtered_reverse_reads[random_samples]) + 
  labs(title = "Trimmed Reverse Read Quality")

# Put the two plots together 
forward_filteredQual_plot_12 + reverse_filteredQual_plot_12
```

# Aggregated Trimmed Plots
```{r}
# Aggregate all QC plots 
# Forward reads
forward_postQC_plot <- 
  plotQualityProfile(filtered_forward_reads, aggregate = TRUE) + 
  labs(title = "Forward Post-QC")

# reverse reads
reverse_postQC_plot <- 
  plotQualityProfile(filtered_reverse_reads, aggregate = TRUE) + 
  labs(title = "Reverse Post-QC")

# Now, let's put the two plots together
postQC_aggregate_plot <- 
  # Plot the forward and reverse together 
  forward_postQC_plot + reverse_postQC_plot
# Show the plot
postQC_aggregate_plot

# INTERPRETATION #2 of Post-QC
```

# Read Retention Post-QC
```{r}
# Make output into dataframe 
filtered_df <- as.data.frame(filtered_reads) %>%
  mutate(percent.retained = reads.out/reads.in)

# Intuition check
# Visualize it in table format 
DT::datatable(filtered_df)
```

```{r}
# Let's calculate some statistics
read_stats_df <- 
  filtered_df %>%
  reframe(median_reads_in = median(reads.in),
          median_reads_out = median(reads.out),
          median_percent_retained = (median(reads.out)/median(reads.in)),
          max_percent_retained = max(reads.out/reads.in),
          min_percent_retained = min(reads.out/reads.in))

# Take a look at it!
read_stats_df
```

```{r}
# Plot it 
numSeqs_QC_dotplot <-
  filtered_df %>%
  ggplot(aes(x = reads.in, y = reads.out)) + 
  geom_point(alpha = 0.5, size = 2) + 
  labs(x = "# of Raw Seqs", 
       y = "# of Seqs Retained") + 
  # Now let's add a 1:1 line for reference of keeping 100% of the reads
  geom_abline(slope=1, intercept = 0, color = "deeppink")

# Now, let's look at the number of reads retained in a histogram
numRetained_QC_histplot <- 
  filtered_df %>%
  ggplot(aes(x = reads.out)) + 
  geom_histogram() + 
  labs(x = "# of Seqs Retained", 
       y = "# of Samples") 

# Create a histogram of percent reads retained in a histogram
percSeqs_QC_histplot <- 
  filtered_df %>%
  ggplot(aes(x = percent.retained)) + 
  geom_histogram() + 
  labs(x = "% of Seqs Retained", 
       y = "# of Samples") + 
  # Set the scale to be between 0-1 (0-100%)
  scale_x_continuous(limits = c(0, 1))

# Now, let's put the plots together
numSeqs_QC_dotplot + numRetained_QC_histplot + percSeqs_QC_histplot + 
  plot_annotation(tag_levels = 'A')

# INTERPRETATION #3 of Post-QC Statistics
```

# Visualize QC differences in plot
```{r}
# Plot the pre and post together in one plot
preQC_aggregate_plot / postQC_aggregate_plot

# INTERPRETATION #4 is comparing your pre-QC to your post-QC read quality.
```

# Check Render Time
```{r}
# Take the time now that we are at the end of the script
end_time <- Sys.time()
end_time 
```
```{r}
# Echo the elapsed time
elapsed_time <- round((end_time - start_time), 3)
elapsed_time
```
# Session Information
```{r}
# Ensure reproducibility 
devtools::session_info()
```

